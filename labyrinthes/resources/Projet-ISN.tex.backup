\documentclass[a4paper,11pt,dvips]{article}
\usepackage{blum}
\usepackage{geometry}
\geometry{hmargin=2cm,vmargin=1cm}
\usepackage{hyperref}
\usepackage{verbatim}
\pagestyle{empty}
\begin{document}
 
\entete{Dans un labyrinthe et \dots autour }{ProjetISN:12/13}

\subsection{Quelques exemples}
  \begin{minipage}{0.5\textwidth}
      \centering \includegraphics[width=5cm]{images_jeux/dm.eps}
      \caption{Un niveau de Dungeon Master} 
  \end{minipage}
  \hfill
  \begin{minipage}{0.5\textwidth}
    \centering \includegraphics[width=5cm]{images_jeux/chartres.eps}
    \caption{Au sol de la cathédrale de Chartres}
  \end{minipage}
  
  \begin{center}
    \centering \includegraphics[width=10cm]{images_jeux/100x100.eps}
    \caption{Un labyrinthe de taille $100\times100$ généré par ordinateur}
    \label{gros}
  \end{center}


  \subsection{Quelques hypothèses}
    
    Un labyrinthe est constitué d'un ensemble de cases. Ces cases seront de deux types :
    \begin{itemize}
      \item un morceau de couloir, c'est à dire une case sur laquelle on peut marcher (en blanc sur les dessins précédents),
      \item ou un mur, c'est à dire une case sur laquelle on ne peut pas marcher (en noir).
    \end{itemize}
    \vfill


      Dans un labyrinthe on veut pouvoir aller d'un point $A$ (l'entrée) à un point $B$ (la sortie) et  
      ces points ne sont pas nécessairement sur la périphérie du labyrinthe (on peut penser au niveau successifs d'un donjon relié par des escaliers).
      Dans certains labyrinthes, aller de $A$ à $B$ sera 
      \begin{itemize}
	\item impossible (le constructeur du labyrinthe est un sadique),
	\item possible par un seul chemin (le constructeur est sympa mais pas trop),
	\item possible par plusieurs chemins (le constructeur est très sympa)\\
      \end{itemize}
      \vfill
      Ces distinctions conduisent à envisager une classification des labyrinthes. 
      Dans la suite on tendra à privilégier le labyrinthes du deuxième type qui seront dit parfaits 
      \footnote{On ira se référer à \url{http://fr.wikipedia.org/wiki/Mod\%C3\%A9lisation_math\%C3\%A9matique_d\%27un_labyrinthe}}.
      \footnote{Le labyrinthe de la figure \ref{gros} est parfait}
      \vfill
      
  \subsection{Représentation du problème}
      Les cases de nos labyrinthes seront carrées et on choisit de les représenter par les cellules d'un tableau à double entrée dans lequel 
      on codera par $0$ la présence d'un mur et par $1$ l'absence de mur. Un tel tableau s'appelle une \emph{matrice}.
      
      \begin{exemple}
      \item
      
       \begin{minipage}{0.5\textwidth}
        \includegraphics[width=9cm]{images_jeux/7x7.eps}
       \end{minipage}
       \hfill
       \begin{minipage}{0.5\textwidth}
	 \begin{tabular}{c|*{7}{c}}
	    \backslashbox{$j$}{$i$} & 0 & 1 & 2 & 3 & 4 & 5 & 6 \\ 
				\hline
				0  & 1 & 1 & 1 & 1 & 1 & 1 & 0 \\
				1  & 0 & 1 & 0 & 0 & 0 & 1 & 1 \\
				2  & 1 & 1 & 1 & 1 & 1 & 0 & 1 \\
				3  & 1 & 0 & 1 & 0 & 1 & 0 & 0 \\
				4  & 1 & 1 & 0 & 1 & 1 & 1 & 1 \\
				5  & 1 & 0 & 1 & 1 & 0 & 1 & 0 \\ 
				6  & 1 & 0 & 1 & 0 & 1 & 1 & 1 \\
	 \end{tabular}
       \end{minipage}

      \end{exemple}


  \subsection{Objectifs}
    \begin{enumerate}[$\bullet$]
     \item \'Etude de la génération de labyrinthe. Conception d'une solution et visualisation graphique des étapes de construction.
     \item \'Etude de méthodes pour chercher la sortie d'un labyrinthe. 
    \end{enumerate}

  \subsection{Modalités}
    Le langage retenu pour mener le projet est \emph{python}. 
    Nous utiliserons la librairie graphique \emph{matplotlib} pour les visualisations et \emph{numpy} pour les manipulations de matrices.
    \begin{enumerate}[$\bullet$]
     \item Séance 1 : \\
	    Distinguer les différents types de labyrinthes.
	    Se familiariser avec l'environnement de travail. \\
	    Sur un exemple facile (génération aléatoire).
	    Jeux avec les paramètres.
	    Sauvegarde sous forme d'une vidéo.
	    Sauvegarde sous forme d'un fichier.
	    Lecture à partir d'un fichier.\\
	    Affichage d'un labyrinthe à partir d'un fichier.
	    
     \item Séance 2 : \\
	    programmer quelques fonctions. \\
	    \og Qualité \fg d'un labyrinthe : 
	    \begin{itemize}
	      \item longueur de la plus grand ligne droite,
	      \item nombre de cul-de-sac,
	      \item nombre virages \dots
	    \end{itemize}
	    Des fichers de labyrinthe seront fournis.
     \item Séance 3 : Un algorithme de génération et sa mise en \oe uvre.
     \item Séance 4 : des idées pour le parcours.
     \item Séance 5 : ajustement / développement en fonction du temps.
     \item Séance 6 : présentation des élèves.
    \end{enumerate}

\newpage
\entete{Mise en route}{ProjetISN:12/13}
\setcounter{subsection}{0}
\subsection{Différents types de labyrinthes}
  Reconnaître parmi les labyrinthes suivants, ceux qui sont parfaits ou non.
  \begin{minipage}{0.3\textwidth}
   
  \end{minipage}

\subsection{Une première idée pour générer un labyrinthe}

Cette partie à pour but de vous familiariser avec les manipulations utiles par la suite du projet. 
Prenez du temps pour tester les programmes, les modifier \dots.

\subsubsection{Entreprise de démolition}
  
Pour générer un labyrinthe, on peut partir d'un d'un labyrinthe rempli de murs et les casser : 

\begin{verbatim}
import numpy as np
import matplotlib.pyplot as plt
"""
Nombre de cases du labyrinthe en ligne  et en colonne 
"""
n = 4
p = 7
"""
Un labyrinthe est initialement rempli de murs
"""
labyrinthe = np.zeros((n,p),int)
"""
On casse un mur
"""
labyrinthe[2,1] = 1
"""
On affiche le resultat
"""
fig = plt.figure()
im = plt.imshow(labyrinthe, interpolation='None', cmap='gist_gray')
plt.show()
\end{verbatim}  

Quels murs seront cassés si j'écris cela ? 
\begin{verbatim}
 for j in range(p):
   labyrinthe[2,j] = 1
\end{verbatim}
 
\begin{remb}
 
\end{remb}



\subsubsection{Vers un premier algorithme \dots}

  Récupérer le fichier \verb?premierAlgorithme.py?. \\
  Vous pouvez le lancer, changer les paramètre \texttt{n}, \texttt{p}, \texttt{murs\_a\_casser}.\\
  Vous devez savoir expliquer son fonctionnement.\\
  
  \begin{remb}
   La ligne \verb?np.savetxt("premierAlgorithme.txt",labyrinthe,fmt="%d")? 
   permet de sauvegarder dans un fichier le labyrinthe.\\
   Ceci permettra de sauvegarder vos labyrinthes sous forme d'un fichier texte.
  \end{remb}



\subsubsection{Animons la démolition}
  Pour effectuer une animation, il faut sauvegarder tous les labyrinthes intermédiaires. 
  Ensuite on les affiche les uns après les autres pour réaliser l'animation voulue.
  Nous allons modifier le script python précédent en ajoutant les lignes suivantes (au bon endroit) : 
  \begin{enumerate}[$\bullet$]
   \item \verb?import matplotlib.animation as animation? dans l'entête pour bénéficier des fonctions d'animation,
   \item On stockera les images dans une liste (initialement vide). \\
	  On ajoute donc avant la boucle \verb?images = []?
   \item \`A la fin de chaque tour de boucle, on sauvegarde l'image du labyrinthe en court :
	\begin{verbatim}
	  im = plt.imshow(np.copy(labyrinthe), interpolation='None', cmap='gist_gray')
	  images.append([im])
	\end{verbatim}
    \item On dessine l'animation
    \begin{verbatim}
ani = animation.ArtistAnimation(fig, images, interval=1, blit=True,repeat_delay=1000)
plt.show()
    \end{verbatim}
  \end{enumerate}

\begin{remb}
  \begin{itemize}
   \item Le script python est disponible sous le nom \texttt{[anim]premierAlgorithme.py}.
   \item Vous remarquerez qu'une ligne permet de sauvegarder le fichier sous forme d'une vidéo 
(attention cela peut ralentir la génération du labyrinthe - désactiver la sauvegarde en mettant un \# devant la ligne pour les gros labyrinthes)
  \end{itemize}

\end{remb}


\subsection{Une autre idée}
  
\end{document}



